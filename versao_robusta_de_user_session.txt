%% ============================================================================
%%  user_session.erl
%%  Gerencia sess√µes de usu√°rios (online/offline, envio de mensagens, etc.)
%% ============================================================================

-module(user_session).
-behaviour(gen_server).

%% API p√∫blica
-export([
    start_link/1,
    user_online/2,
    user_offline/1,
    get_status/1,
    send_message/3,
    get_online_users/0,
    get_online_user_ids/0
]).

%% Callbacks
-export([
    init/1,
    handle_call/3,
    handle_cast/2,
    handle_info/2
]).

-record(state, {
    user_id        :: binary(),
    ws_pid         :: pid() | undefined,
    status = offline :: online | offline,
    last_seen      :: integer()
}).

%% ============================================================================
%%  API
%% ============================================================================

start_link(UserId) ->
    gen_server:start_link(?MODULE, [UserId], []).

user_online(UserId, WsPid) ->
    case whereis(get_process_name(UserId)) of
        undefined ->
            {ok, Pid} = start_link(UserId),
            gen_server:cast(Pid, {user_online, WsPid});
        Pid ->
            gen_server:cast(Pid, {user_online, WsPid})
    end.

user_offline(UserId) ->
    case whereis(get_process_name(UserId)) of
        undefined -> ok;
        Pid -> gen_server:cast(Pid, user_offline)
    end.

get_status(UserId) ->
    case whereis(get_process_name(UserId)) of
        undefined -> {error, user_not_found};
        Pid -> gen_server:call(Pid, get_status)
    end.

send_message(FromId, ToId, Message) ->
    case whereis(get_process_name(ToId)) of
        undefined ->
            {error, user_offline};
        Pid ->
            gen_server:cast(Pid, {send_message, FromId, Message})
    end.

%% ============================================================================
%%  Consultas via GPROC
%% ============================================================================

%% Retorna PIDs de todos usu√°rios online
get_online_users() ->
    Pattern = {{n, l, {user_session, '$1'}}, '_', '_'},
    MatchHead = Pattern,
    Guard = [],
    Result = ['$1'],

    gproc:select([{MatchHead, Guard, Result}]).


%% Retorna IDs de usu√°rios online (<<"user_001">>)
get_online_user_ids() ->
    Match = {{n, l, {user_session, '$1'}}, '_', '_'},
    [UserId || {{_, _, {user_session, UserId}}, _Pid, _Val} <- gproc:select([Match])].

%% ============================================================================
%%  Callbacks do gen_server
%% ============================================================================

init([UserId]) ->
    ProcessName = get_process_name(UserId),
    register(ProcessName, self()),

    %% Registro no gproc
    gproc:reg({n, l, {user_session, UserId}}),

    {ok, #state{user_id = UserId}}.

handle_cast({user_online, WsPid}, State) ->
    Now = erlang:system_time(second),
    io:format("‚úÖ User ~p is now online~n", [State#state.user_id]),
    {noreply, State#state{
        ws_pid = WsPid,
        status = online,
        last_seen = Now
    }};

handle_cast(user_offline, State) ->
    io:format("üîå User ~p is now offline~n", [State#state.user_id]),
    {noreply, State#state{
        ws_pid = undefined,
        status = offline
    }};

%% Recebe mensagem de outro usu√°rio
handle_cast({send_message, FromId, Message}, State = #state{ws_pid = WsPid, status = online}) ->
    EnhancedMessage =
        case maps:is_key(<<"from">>, Message) of
            true -> Message;
            false -> Message#{<<"from">> => FromId}
        end,

    WsPid ! {send_message, EnhancedMessage},

    io:format("üì§ Enviando mensagem de ~p para ~p: ~p~n",
              [FromId, State#state.user_id, EnhancedMessage]),

    {noreply, State};

%% Se o usu√°rio est√° offline, apenas imprime (depois integrar com Mnesia)
handle_cast({send_message, _FromId, _Msg}, State = #state{status = offline}) ->
    io:format("üíæ Usu√°rio ~p offline - mensagem armazenada~n",
              [State#state.user_id]),
    {noreply, State}.

handle_call(get_status, _From, State) ->
    {reply, {ok, State#state.status}, State}.

handle_info(_Info, State) ->
    {noreply, State}.

%% ============================================================================
%%  Util
%% ============================================================================

get_process_name(UserId) when is_binary(UserId) ->
    get_process_name(binary_to_list(UserId));

get_process_name(UserId) ->
    list_to_atom("user_session_" ++ UserId).

