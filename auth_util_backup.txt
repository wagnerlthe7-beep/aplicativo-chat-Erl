%% -------------------------------------------------------------------
%% auth_util.erl
%% Funções de validação Firebase, Postgres e criação de token de sessão
%% -------------------------------------------------------------------

-module(auth_util).
-export([verify_firebase_token/1, get_or_create_user/2, create_session_token/1]).

-include_lib("kernel/include/logger.hrl").

%% Defaults
-define(DEFAULT_DB_HOST, "localhost").
-define(DEFAULT_DB_PORT, 5432).
-define(DEFAULT_DB_NAME, "chat_app_db").
-define(DEFAULT_DB_USER, "postgres").

%% -------------------------------------------------------------------
%% 1) Verifica idToken usando Firebase REST API (accounts:lookup)
%% -------------------------------------------------------------------
verify_firebase_token(IdToken) when is_binary(IdToken); is_list(IdToken) ->
    ApiKey0 = os:getenv("FIREBASE_API_KEY"),
    ApiKey = case ApiKey0 of
                 false -> undefined;
                 V -> V
             end,
    case ApiKey of
        undefined ->
            {error, #{reason => "no_firebase_api_key_env"}};
        _ ->
            application:ensure_all_started(inets),
            application:ensure_all_started(ssl),
            Url = "https://identitytoolkit.googleapis.com/v1/accounts:lookup?key=" ++ ApiKey,

            %% garante que o token seja binário
            IdTokenBin = case IdToken of
                             I when is_list(I) -> list_to_binary(I);
                             I when is_binary(I) -> I
                         end,

            BodyMap = #{<<"idToken">> => IdTokenBin},
            BodyJson = jsx:encode(BodyMap),
            Headers = [{"Content-Type", "application/json"}],
            Request = {Url, Headers, "application/json", BodyJson},

            %% faz a requisição
            case httpc:request(post, Request, [], []) of
                {ok, {{_, 200, _}, _RespHeaders, RespBody}} ->
                    RespBodyBin = case RespBody of
                                      B when is_binary(B) -> B;
                                      L when is_list(L) -> list_to_binary(L)
                                  end,
                    case catch jsx:decode(RespBodyBin, [return_maps]) of
                        Map when is_map(Map) ->
                            Users = maps:get(<<"users">>, Map, undefined),
                            case Users of
                                [First|_] when is_map(First) -> {ok, First};
                                _ -> {error, #{reason => "no_users_in_response", body => RespBodyBin}}
                            end;
                        _ ->
                            {error, #{reason => invalid_json_response, body => RespBodyBin}}
                    end;

                {ok, {{_, Code, ReasonPhrase}, _RespHeaders, RespBody}} ->
                    {error, #{firebase_api_error => Code, reason_phrase => ReasonPhrase, body => RespBody}};

                {error, Reason} ->
                    {error, #{http_error => Reason}}
            end
    end.

%% -------------------------------------------------------------------
%% 2) Verifica/cria user no Postgres
%% -------------------------------------------------------------------
get_or_create_user(Phone, FirebaseUid) ->
    %% ler env com case seguro
    Host0 = os:getenv("DB_HOST"),
    Host = case Host0 of false -> ?DEFAULT_DB_HOST; H -> H end,

    Port0 = os:getenv("DB_PORT"),
    Port = case Port0 of
               false -> ?DEFAULT_DB_PORT;
               V when is_list(V) ->
                   (catch list_to_integer(V)) orelse ?DEFAULT_DB_PORT;
               V when is_integer(V) -> V
           end,

    DbName0 = os:getenv("DB_NAME"),
    DbName = case DbName0 of false -> ?DEFAULT_DB_NAME; N -> N end,

    DbUser0 = os:getenv("DB_USER"),
    DbUser = case DbUser0 of false -> ?DEFAULT_DB_USER; U -> U end,

    DbPass0 = os:getenv("DB_PASS"),
    DbPass = case DbPass0 of false -> ""; P -> P end,

    %% Conectar
    case epgsql:connect(Host, DbUser, DbPass, [{database, DbName}, {port, Port}]) of
        {ok, Conn} ->
            SelectSql = "SELECT id, name, phone, is_active, profile_picture FROM users WHERE phone = $1",
            case epgsql:squery(Conn, SelectSql, [Phone]) of
                {ok, Rows} when Rows =/= [] ->
                    Row = hd(Rows),
                    case Row of
                        {Id, Name, PhoneDb, IsActive, ProfilePicture} ->
                            _ = maybe_update_firebase_uid(Conn, Id, FirebaseUid),
                            _ = epgsql:squery(Conn, "UPDATE users SET last_login = now() WHERE id = $1", [Id]),
                            UserMap = #{id => Id, name => Name, phone => PhoneDb, is_active => IsActive, profile_picture => ProfilePicture},
                            {ok, UserMap};
                        _ -> {error, unexpected_row_format}
                    end;
                {ok, []} ->
                    DefaultName = "Usuário",
                    InsertSql = "INSERT INTO users (name, phone, is_active, created_at, firebase_uid) VALUES ($1, $2, true, now(), $3) RETURNING id, name, phone, is_active",
                    case epgsql:squery(Conn, InsertSql, [DefaultName, Phone, FirebaseUid]) of
                        {ok, InsertRows} when InsertRows =/= [] ->
                            InsertRow = hd(InsertRows),
                            case InsertRow of
                                {Id, Name, PhoneDb, IsActive} ->
                                    UserMap = #{id => Id, name => Name, phone => PhoneDb, is_active => IsActive},
                                    {ok, UserMap};
                                _ -> {error, unexpected_insert_format}
                            end;
                        {error, Err} -> {error, {db_insert_error, Err}};
                        _ -> {error, insert_failed}
                    end;
                {error, Err} -> {error, {db_select_error, Err}}
            end;
        {error, Err} -> {error, {db_connect_error, Err}}
    end.

%% Atualiza firebase_uid se necessário
maybe_update_firebase_uid(_Conn, _Id, undefined) -> ok;
maybe_update_firebase_uid(Conn, Id, FirebaseUid) ->
    case is_list(FirebaseUid) orelse is_binary(FirebaseUid) of
        true ->
            catch epgsql:squery(Conn,
                "UPDATE users SET firebase_uid = $1 WHERE id = $2 AND (firebase_uid IS NULL OR firebase_uid = '')",
                [FirebaseUid, Id]),
            ok;
        false -> ok
    end.

%% -------------------------------------------------------------------
%% 3) Criar JWT HS256 (simples)
%% -------------------------------------------------------------------
create_session_token(UserMap) when is_map(UserMap) ->
    case os:getenv("SESSION_SECRET") of
        false -> {error, "no_session_secret_env"};
        SecretStr ->
            SecretBin = list_to_binary(SecretStr),
            Header = [{<<"alg">>, <<"HS256">>}, {<<"typ">>, <<"JWT">>}],
            Iat = erlang:system_time(second),
            Exp = Iat + 3600,
            Claims = [
                {<<"user_id">>, maps:get(id, UserMap)},
                {<<"phone">>, maps:get(phone, UserMap)},
                {<<"iat">>, Iat},
                {<<"exp">>, Exp}
            ],
            HJson = jsx:encode(Header),
            PJson = jsx:encode(Claims),
            HBase = base64url(list_to_binary(HJson)),
            PBase = base64url(list_to_binary(PJson)),
            SigningInput = <<HBase/binary, $., PBase/binary>>,
            SigRaw = crypto:mac(hmac, sha256, SecretBin, SigningInput),
            SigBase = base64url(SigRaw),
            TokenBin = <<HBase/binary, $., PBase/binary, $., SigBase/binary>>,
            {ok, binary_to_list(TokenBin)}
    end.

%% -------------------------------------------------------------------
%% Base64url helper
%% -------------------------------------------------------------------
base64url(Bin) when is_binary(Bin) ->
    Enc = base64:encode(Bin),
    Enc1 = binary:replace(Enc, <<"+">>, <<"-">>, [global]),
    Enc2 = binary:replace(Enc1, <<"/">>, <<"_">>, [global]),
    re:replace(Enc2, "=+$", "", [global, {return, binary}]);
base64url(Str) when is_list(Str) -> base64url(list_to_binary(Str)).