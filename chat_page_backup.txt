import 'package:flutter/material.dart';
import 'package:flutter_contacts/flutter_contacts.dart';
import 'package:uuid/uuid.dart';
import 'chat_service.dart';
import 'auth_service.dart';
import 'dart:async';

class ChatPage extends StatefulWidget {
  final Contact contact;
  final String remoteUserId;

  const ChatPage({Key? key, required this.contact, required this.remoteUserId})
    : super(key: key);

  @override
  _ChatPageState createState() => _ChatPageState();
}

class _ChatPageState extends State<ChatPage> {
  final TextEditingController _messageController = TextEditingController();
  final List<ChatMessage> _messages = [];
  final ScrollController _scrollController = ScrollController();

  // ‚úÖ CONTROLE DE ESTADO MELHORADO
  String? _currentUserId;
  bool _isConnected = false;
  bool _isLoadingHistory = false;
  StreamSubscription? _messageSubscription;

  // ‚úÖ CONTROLE DE MENSAGENS TEMPOR√ÅRIAS (evitar duplicatas na UI)
  final Set<String> _pendingMessageIds = {};

  // ‚úÖ UUID PARA GERAR IDs TEMPOR√ÅRIOS
  final Uuid _uuid = Uuid();

  @override
  void initState() {
    super.initState();
    _initializeChat();
  }

  @override
  void dispose() {
    _messageSubscription?.cancel();
    _pendingMessageIds.clear();
    super.dispose();
  }

  void _initializeChat() async {
    try {
      print('üöÄ Inicializando chat din√¢mico...');

      _currentUserId = await AuthService.getCurrentUserId();
      print('   - Current User ID: $_currentUserId');

      if (_currentUserId == null) {
        print('‚ùå N√£o foi poss√≠vel obter o user_id atual');
        return;
      }

      await _setupRealChat();
      await _loadChatHistory();
    } catch (e) {
      print('‚ùå Erro na inicializa√ß√£o do chat: $e');
    }
  }

  Future<void> _setupRealChat() async {
    final connected = await ChatService.connect();

    if (connected && mounted) {
      setState(() {
        _isConnected = true;
      });

      // ‚úÖ OUVIR MENSAGENS COM CONTROLE DE DUPLICATAS
      _messageSubscription = ChatService.messageStream.listen((message) {
        print('üí¨ Mensagem recebida: $message');
        _handleIncomingMessage(message);
      });
    } else {
      print('‚ùå Falha na conex√£o WebSocket');
    }
  }

  void _handleIncomingMessage(Map<String, dynamic> message) {
    final fromUserId = message['from']?.toString();
    final toUserId = message['to']?.toString();
    final messageId = message['message_id']?.toString();
    final content = message['content']?.toString() ?? '';

    // ‚úÖ VERIFICAR SE A MENSAGEM √â PARA ESTE CHAT
    final isMessageForThisChat =
        (fromUserId == widget.remoteUserId && toUserId == _currentUserId) ||
        (fromUserId == _currentUserId && toUserId == widget.remoteUserId);

    if (isMessageForThisChat && mounted) {
      final isFromMe = fromUserId == _currentUserId;

      // ‚úÖ EVITAR DUPLICATAS NA UI
      final isPendingMessage = _pendingMessageIds.contains(messageId);
      final isDuplicate = _messages.any(
        (msg) => msg.text == content && msg.isMe == isFromMe,
      );

      if (!isDuplicate && !isPendingMessage) {
        // ‚úÖ USAR TIMESTAMP DO SERVIDOR PARA MENSAGENS EM TEMPO REAL
        final serverTimestamp = _parseRealTimeMessageTimestamp(message);
        print(
          '‚úÖ Adicionando mensagem √† UI: "$content" - Timestamp: $serverTimestamp',
        );

        setState(() {
          _messages.add(
            ChatMessage(
              text: content,
              isMe: isFromMe,
              timestamp: serverTimestamp,
            ),
          );
        });
        _scrollToBottom();

        // ‚úÖ SE √â MENSAGEM PR√ìPRIA PENDENTE, REMOVER DO CONTROLE
        if (isFromMe && messageId != null) {
          _pendingMessageIds.remove(messageId);
        }
      } else {
        print('üîÑ Ignorando mensagem duplicada: $content');
      }
    }
  }

  // ‚úÖ NOVA FUN√á√ÉO: Parsear timestamp de mensagens em tempo real
  DateTime _parseRealTimeMessageTimestamp(Map<String, dynamic> message) {
    try {
      final timestamp = message['timestamp'];
      print('üîç Parseando timestamp em tempo real: $timestamp');

      if (timestamp is int) {
        // Se for int, verificar se √© segundos ou milissegundos
        if (timestamp > 1000000000000) {
          // Provavelmente milissegundos (ex: 1642252800000)
          return DateTime.fromMillisecondsSinceEpoch(timestamp);
        } else {
          // Provavelmente segundos (ex: 1642252800)
          return DateTime.fromMillisecondsSinceEpoch(timestamp * 1000);
        }
      } else if (timestamp is String) {
        // Tentar parsear como string
        return DateTime.parse(timestamp);
      }
    } catch (e) {
      print('‚ùå Erro ao parsear timestamp em tempo real: $e');
    }

    // ‚úÖ FALLBACK: Se n√£o conseguir, usar timestamp atual
    return DateTime.now();
  }

  // ‚úÖ CORRE√á√ÉO: Usar timestamp do servidor para mensagens do hist√≥rico
  Future<void> _loadChatHistory() async {
    if (_isLoadingHistory || _currentUserId == null) return;

    setState(() => _isLoadingHistory = true);

    try {
      print('üìú Carregando hist√≥rico din√¢mico...');
      final history = await ChatService.loadChatHistory(widget.remoteUserId);

      if (mounted && history.isNotEmpty) {
        setState(() {
          _messages.addAll(
            history.map((msg) {
              // ‚úÖ USAR TIMESTAMP DO SERVIDOR, N√ÉO ATUAL
              final serverTimestamp = _parseMessageTimestamp(msg);

              return ChatMessage(
                text: msg['content'] ?? '',
                isMe: _isMessageFromMe(msg),
                timestamp: serverTimestamp,
              );
            }).toList(),
          );
          print('‚úÖ ${history.length} mensagens carregadas no hist√≥rico');
        });
        _scrollToBottom();

        // ‚úÖ DEBUG FINAL DO CARREGAMENTO
        print('üìä RESUMO DO CARREGAMENTO:');
        print('   - Total de mensagens carregadas: ${_messages.length}');
        print('   - Timestamps das mensagens:');
        for (int i = 0; i < _messages.length && i < 5; i++) {
          final msg = _messages[i];
          print('     ${i + 1}. "${msg.text}" -> ${msg.timestamp}');
        }
        if (_messages.length > 5) {
          print('     ... e mais ${_messages.length - 5} mensagens');
        }
      }
    } catch (e) {
      print('‚ùå Erro ao carregar hist√≥rico: $e');
    } finally {
      if (mounted) {
        setState(() => _isLoadingHistory = false);
      }
    }
  }

  // ‚úÖ CORRE√á√ÉO: Parse de timestamp com ajuste de +2 horas
  DateTime _parseMessageTimestamp(Map<String, dynamic> message) {
    print('üïí === DEBUG TIMESTAMP INICIO ===');
    print('   Mensagem: ${message['content']}');
    print(
      '   sent_at: ${message['sent_at']} (tipo: ${message['sent_at']?.runtimeType})',
    );

    try {
      final sentAt = message['sent_at'];
      DateTime parsedDateTime;

      // ‚úÖ FORMATO ERLANG TUPLE: {{2025,11,19},{14,36,8.150417}}
      if (sentAt is String && sentAt.contains('{{')) {
        print('   üîç Detectado formato Erlang Tuple');
        parsedDateTime = _parseErlangTupleTimestamp(sentAt);
      }
      // ‚úÖ FORMATO ISO 8601
      else if (sentAt is String) {
        print('   üîç Tentando parse como ISO 8601');
        parsedDateTime = DateTime.parse(sentAt);
      }
      // ‚úÖ TIMESTAMP UNIX (segundos)
      else if (sentAt is int) {
        print('   üîç Tentando como timestamp Unix (segundos)');
        parsedDateTime = DateTime.fromMillisecondsSinceEpoch(sentAt * 1000);
      }
      // ‚úÖ TENTAR CAMPO timestamp COMO FALLBACK
      else {
        final timestamp = message['timestamp'];
        if (timestamp != null && timestamp is int) {
          print('   üîç Tentando campo timestamp como fallback: $timestamp');
          if (timestamp > 1000000000000) {
            parsedDateTime = DateTime.fromMillisecondsSinceEpoch(timestamp);
          } else {
            parsedDateTime = DateTime.fromMillisecondsSinceEpoch(
              timestamp * 1000,
            );
          }
        } else {
          throw FormatException('Nenhum formato reconhecido');
        }
      }

      // ‚úÖ CORRE√á√ÉO: ADICIONAR 2 HORAS A TODOS OS TIMESTAMPS
      final correctedDateTime = parsedDateTime.add(Duration(hours: 2));

      print('   ‚úÖ Parseado original: $parsedDateTime');
      print('   ‚úÖ Com corre√ß√£o +2h: $correctedDateTime');
      print('üïí === DEBUG TIMESTAMP FIM ===');

      return correctedDateTime;
    } catch (e) {
      print('   ‚ùå‚ùå‚ùå ERRO CR√çTICO: $e');
      print('   ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è USANDO FALLBACK - HORA ATUAL');
      return DateTime.now();
    }
  }

  // ‚úÖ FUN√á√ÉO AUXILIAR: Parse Erlang Tuple (sem corre√ß√£o aqui)
  DateTime _parseErlangTupleTimestamp(String erlangTimestamp) {
    try {
      print('   üîÑ Parseando Erlang Tuple: $erlangTimestamp');

      final regex = RegExp(
        r'\{\{(\d+),(\d+),(\d+)\},\{(\d+),(\d+),([\d.]+)\}\}',
      );
      final match = regex.firstMatch(erlangTimestamp);

      if (match != null) {
        final year = int.parse(match.group(1)!);
        final month = int.parse(match.group(2)!);
        final day = int.parse(match.group(3)!);
        final hour = int.parse(match.group(4)!);
        final minute = int.parse(match.group(5)!);
        final secondWithMs = double.parse(match.group(6)!);
        final second = secondWithMs.toInt();

        return DateTime(year, month, day, hour, minute, second);
      }
    } catch (e) {
      print('   ‚ùå Erro no parse Erlang: $e');
    }

    throw FormatException('N√£o foi poss√≠vel parsear formato Erlang');
  }

  bool _isMessageFromMe(Map<String, dynamic> message) {
    final senderId = message['sender_id']?.toString();
    return senderId == _currentUserId;
  }

  // ‚úÖ ENVIAR MENSAGEM COM UUID (MAIS CONFI√ÅVEL)
  void _sendMessage() {
    final text = _messageController.text.trim();
    if (text.isEmpty || !_isConnected || _currentUserId == null) return;

    // ‚úÖ GERAR ID TEMPOR√ÅRIO √öNICO COM UUID (MAIS CONFI√ÅVEL)
    final tempMessageId =
        'temp_${DateTime.now().millisecondsSinceEpoch}_${_currentUserId}_${_uuid.v4().substring(0, 6)}';

    print('üì§ Enviando mensagem: $text (ID: $tempMessageId)');

    // ‚úÖ REGISTRAR COMO PENDENTE (evitar eco)
    _pendingMessageIds.add(tempMessageId);

    // ‚úÖ ADICIONAR FEEDBACK VISUAL IMEDIATO (APENAS UMA VEZ)
    setState(() {
      _messages.add(
        ChatMessage(text: text, isMe: true, timestamp: DateTime.now()),
      );
    });

    _messageController.clear();
    _scrollToBottom();

    // ‚úÖ ENVIAR VIA WEBSOCKET COM ID TEMPOR√ÅRIO
    ChatService.sendMessage(widget.remoteUserId, text, tempId: tempMessageId);
  }

  void _scrollToBottom() {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (_scrollController.hasClients) {
        _scrollController.animateTo(
          _scrollController.position.maxScrollExtent,
          duration: Duration(milliseconds: 300),
          curve: Curves.easeOut,
        );
      }
    });
  }

  // ‚úÖ FUN√á√ÉO PARA FORMATAR DATA ESTILO WHATSAPP
  String _formatDateHeader(DateTime date) {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final yesterday = DateTime(now.year, now.month, now.day - 1);
    final dateDay = DateTime(date.year, date.month, date.day);

    if (dateDay == today) {
      return 'Hoje';
    } else if (dateDay == yesterday) {
      return 'Ontem';
    } else {
      // Formatar como "20 de Novembro"
      final months = [
        'Janeiro',
        'Fevereiro',
        'Mar√ßo',
        'Abril',
        'Maio',
        'Junho',
        'Julho',
        'Agosto',
        'Setembro',
        'Outubro',
        'Novembro',
        'Dezembro',
      ];
      return '${date.day} de ${months[date.month - 1]}';
    }
  }

  // ‚úÖ CORRE√á√ÉO: Agrupamento correto de mensagens
  List<MessageGroup> _groupMessagesByDate() {
    if (_messages.isEmpty) return [];

    final groups = <MessageGroup>[];

    // Ordenar mensagens por timestamp (mais antigas primeiro)
    final sortedMessages = List<ChatMessage>.from(_messages)
      ..sort((a, b) => a.timestamp.compareTo(b.timestamp));

    DateTime? currentDate;
    List<ChatMessage> currentGroup = [];

    for (final message in sortedMessages) {
      final messageDate = DateTime(
        message.timestamp.year,
        message.timestamp.month,
        message.timestamp.day,
      );

      if (currentDate == null || messageDate != currentDate) {
        // Nova data - criar novo grupo
        if (currentGroup.isNotEmpty) {
          groups.add(
            MessageGroup(date: currentDate!, messages: List.from(currentGroup)),
          );
        }
        currentDate = messageDate;
        currentGroup = [message];
      } else {
        // Mesma data - adicionar ao grupo atual
        currentGroup.add(message);
      }
    }

    // Adicionar o √∫ltimo grupo
    if (currentGroup.isNotEmpty) {
      groups.add(
        MessageGroup(date: currentDate!, messages: List.from(currentGroup)),
      );
    }

    print('üìÖ Grupos criados: ${groups.length}');
    for (final group in groups) {
      print(
        '   - ${_formatDateHeader(group.date)}: ${group.messages.length} mensagens',
      );
    }

    return groups;
  }

  // ‚úÖ FUN√á√ÉO AUXILIAR: Calcular total de itens (headers + mensagens)
  int _calculateTotalItemCount(List<MessageGroup> groups) {
    int count = 0;
    for (final group in groups) {
      count += 1 + group.messages.length; // 1 header + N mensagens
    }
    return count;
  }

  // ‚úÖ FUN√á√ÉO AUXILIAR: Obter item no √≠ndice correto
  dynamic _getItemAtIndex(List<MessageGroup> groups, int index) {
    int currentIndex = 0;

    for (final group in groups) {
      // Header da data
      if (index == currentIndex) {
        return group.date;
      }
      currentIndex++;

      // Mensagens do grupo
      for (final message in group.messages) {
        if (index == currentIndex) {
          return message;
        }
        currentIndex++;
      }
    }

    return null;
  }

  // ‚úÖ FUN√á√ÉO AUXILIAR: Estado vazio
  Widget _buildEmptyState() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.chat_bubble_outline, size: 80, color: Colors.grey[300]),
          SizedBox(height: 16),
          Text(
            'Inicie uma conversa',
            style: TextStyle(color: Colors.grey[500], fontSize: 16),
          ),
          SizedBox(height: 8),
          Text(
            _currentUserId == null
                ? 'Carregando usu√°rio...'
                : _isConnected
                ? 'Envie uma mensagem para come√ßar'
                : 'Conectando ao servidor...',
            style: TextStyle(color: Colors.grey[400], fontSize: 14),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final messageGroups = _groupMessagesByDate();

    return Scaffold(
      backgroundColor: Colors.white,
      appBar: AppBar(
        backgroundColor: Colors.green,
        elevation: 0,
        leading: IconButton(
          icon: Icon(Icons.arrow_back, color: Colors.white),
          onPressed: () => Navigator.pop(context),
        ),
        title: Row(
          children: [
            widget.contact.photo != null
                ? CircleAvatar(
                    radius: 18,
                    backgroundImage: MemoryImage(widget.contact.photo!),
                  )
                : CircleAvatar(
                    radius: 18,
                    backgroundColor: Colors.white,
                    child: Icon(Icons.person, color: Colors.green, size: 20),
                  ),
            SizedBox(width: 12),
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  widget.contact.displayName.isEmpty
                      ? 'Sem nome'
                      : widget.contact.displayName,
                  style: TextStyle(
                    color: Colors.white,
                    fontSize: 16,
                    fontWeight: FontWeight.w500,
                  ),
                ),
                Text(
                  _isConnected ? 'online' : 'conectando...',
                  style: TextStyle(
                    color: _isConnected
                        ? Colors.white.withOpacity(0.8)
                        : Colors.orange,
                    fontSize: 12,
                  ),
                ),
              ],
            ),
          ],
        ),
        actions: [
          IconButton(
            icon: Icon(Icons.videocam, color: Colors.white),
            onPressed: () {},
          ),
          IconButton(
            icon: Icon(Icons.call, color: Colors.white),
            onPressed: () {},
          ),
          PopupMenuButton<String>(
            icon: Icon(Icons.more_vert, color: Colors.white),
            onSelected: (value) {},
            itemBuilder: (context) => [
              PopupMenuItem(
                value: 'info',
                child: Text('Informa√ß√µes do contato'),
              ),
              PopupMenuItem(
                value: 'mute',
                child: Text('Silenciar notifica√ß√µes'),
              ),
            ],
          ),
        ],
      ),
      body: Column(
        children: [
          if (_isLoadingHistory)
            LinearProgressIndicator(
              backgroundColor: Colors.green[100],
              valueColor: AlwaysStoppedAnimation<Color>(Colors.green),
            ),
          Expanded(
            child: _messages.isEmpty && !_isLoadingHistory
                ? _buildEmptyState()
                : ListView.builder(
                    controller: _scrollController,
                    padding: EdgeInsets.all(16),
                    itemCount: _calculateTotalItemCount(messageGroups),
                    itemBuilder: (context, index) {
                      final item = _getItemAtIndex(messageGroups, index);

                      if (item is DateTime) {
                        // Header de data
                        return _buildDateHeader(item);
                      } else if (item is ChatMessage) {
                        // Mensagem
                        return _buildMessageBubble(item);
                      } else {
                        return SizedBox.shrink();
                      }
                    },
                  ),
          ),
          _buildMessageInput(),
        ],
      ),
    );
  }

  // ‚úÖ WIDGET PARA HEADER DE DATA
  Widget _buildDateHeader(DateTime date) {
    return Container(
      width: double.infinity,
      padding: EdgeInsets.symmetric(vertical: 8),
      child: Center(
        child: Container(
          padding: EdgeInsets.symmetric(horizontal: 16, vertical: 6),
          decoration: BoxDecoration(
            color: Colors.grey[300],
            borderRadius: BorderRadius.circular(12),
          ),
          child: Text(
            _formatDateHeader(date),
            style: TextStyle(
              color: Colors.grey[700],
              fontSize: 12,
              fontWeight: FontWeight.w500,
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildMessageInput() {
    return Container(
      padding: EdgeInsets.all(16),
      color: Colors.grey[50],
      child: Row(
        children: [
          IconButton(
            icon: Icon(Icons.attach_file, color: Colors.grey[600]),
            onPressed: () {},
          ),
          Expanded(
            child: Container(
              decoration: BoxDecoration(
                color: Colors.white,
                borderRadius: BorderRadius.circular(25),
                border: Border.all(color: Colors.grey[300]!),
              ),
              child: Row(
                children: [
                  Expanded(
                    child: TextField(
                      controller: _messageController,
                      decoration: InputDecoration(
                        hintText: 'Digite uma mensagem...',
                        hintStyle: TextStyle(color: Colors.grey[500]),
                        border: InputBorder.none,
                        contentPadding: EdgeInsets.symmetric(
                          horizontal: 16,
                          vertical: 12,
                        ),
                      ),
                      onSubmitted: (_) => _sendMessage(),
                    ),
                  ),
                  IconButton(
                    icon: Icon(
                      Icons.emoji_emotions_outlined,
                      color: Colors.grey[600],
                    ),
                    onPressed: () {},
                  ),
                ],
              ),
            ),
          ),
          SizedBox(width: 8),
          Container(
            decoration: BoxDecoration(
              color: _isConnected ? Colors.green : Colors.grey,
              shape: BoxShape.circle,
            ),
            child: IconButton(
              icon: Icon(Icons.send, color: Colors.white),
              onPressed: _isConnected ? _sendMessage : null,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildMessageBubble(ChatMessage message) {
    return Container(
      margin: EdgeInsets.symmetric(vertical: 4),
      child: Row(
        mainAxisAlignment: message.isMe
            ? MainAxisAlignment.end
            : MainAxisAlignment.start,
        children: [
          if (!message.isMe) ...[
            widget.contact.photo != null
                ? CircleAvatar(
                    radius: 16,
                    backgroundImage: MemoryImage(widget.contact.photo!),
                  )
                : CircleAvatar(
                    radius: 16,
                    backgroundColor: Colors.green[100],
                    child: Icon(Icons.person, color: Colors.green, size: 16),
                  ),
            SizedBox(width: 8),
          ],
          Flexible(
            child: Container(
              padding: EdgeInsets.symmetric(horizontal: 16, vertical: 10),
              decoration: BoxDecoration(
                color: message.isMe ? Colors.green : Colors.grey[200],
                borderRadius: BorderRadius.circular(18),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    message.text,
                    style: TextStyle(
                      color: message.isMe ? Colors.white : Colors.grey[800],
                      fontSize: 16,
                    ),
                  ),
                  SizedBox(height: 4),
                  Text(
                    _formatTime(message.timestamp),
                    style: TextStyle(
                      color: message.isMe
                          ? Colors.white.withOpacity(0.7)
                          : Colors.grey[500],
                      fontSize: 10,
                    ),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }

  String _formatTime(DateTime timestamp) {
    return '${timestamp.hour.toString().padLeft(2, '0')}:${timestamp.minute.toString().padLeft(2, '0')}';
  }
}

class ChatMessage {
  final String text;
  final bool isMe;
  final DateTime timestamp;

  ChatMessage({
    required this.text,
    required this.isMe,
    required this.timestamp,
  });
}

// ‚úÖ CLASSE PARA AGRUPAR MENSAGENS POR DATA
class MessageGroup {
  final DateTime date;
  final List<ChatMessage> messages;

  MessageGroup({required this.date, required this.messages});
}
